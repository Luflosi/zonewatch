// SPDX-FileCopyrightText: 2024 Luflosi <zonewatch@luflosi.de>
// SPDX-License-Identifier: GPL-3.0-only

use crate::db;
use atomic_write_file::{AtomicWriteFile, unix::OpenOptionsExt as AtomicOpenOptionsExt};
use blake3::Hash;
use color_eyre::eyre::{Result, WrapErr, eyre};
use indoc::formatdoc;
use log::{debug, error, trace, warn};
use sqlx::{Sqlite, Transaction};
use std::{
	collections::HashMap,
	fs,
	io::Write,
	os::unix::fs::OpenOptionsExt as UnixOpenOptionsExt,
	path::{Path, PathBuf},
};

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Zone {
	pub name: String,
	pub dir: PathBuf,
	pub ttl: String,
	pub includes: HashMap<PathBuf, Include>,
	pub includes_ordered: Vec<PathBuf>,
	pub soa: Soa,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum Include {
	Readable(Hash),
	// Provide a better user experience by explicitly handling the two probably most common errors
	NotFound,
	PermissionDenied,
	OtherError,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Soa {
	pub ttl: String,
	pub mname: String,
	pub rname: String,
	pub serial: u32,
	pub refresh: String,
	pub retry: String,
	pub expire: String,
	pub minimum: String,
}

impl Include {
	pub fn read_from_fs(zone_name: &str, file_path: &Path) -> Self {
		trace!("Hashing file {}", file_path.display());
		match fs::read_to_string(file_path) {
			Ok(contents) => {
				let hash = blake3::hash(contents.as_bytes());
				debug!(
					"Hash of file {} (included in zone {zone_name}): {}",
					file_path.display(),
					hash
				);
				Self::Readable(hash)
			}
			Err(e) => match e.kind() {
				std::io::ErrorKind::NotFound => {
					warn!(
						"File {} included in zone {zone_name} is missing",
						file_path.display()
					);
					Self::NotFound
				}
				std::io::ErrorKind::PermissionDenied => {
					warn!(
						"Permission denied reading file {} included in zone {zone_name}",
						file_path.display()
					);
					Self::PermissionDenied
				}
				_ => {
					error!(
						"Error reading file {} included in {zone_name}: {}",
						file_path.display(),
						e
					);
					Self::OtherError
				}
			},
		}
	}

	pub fn files_from_paths<'a>(
		zone_name: &str,
		paths: impl Iterator<Item = &'a PathBuf>,
	) -> HashMap<PathBuf, Self> {
		paths
			.map(|path| (path.clone(), Self::read_from_fs(zone_name, path)))
			.collect()
	}
}

fn construct_contents(zone: &Zone) -> String {
	let mut zone_data = formatdoc! {"
		; This file was automatically generated by zonewatch.
		; Do not edit or your changes will be overwritten!

		$ORIGIN {}.
		$TTL {}
		@ {} IN SOA {} {} (
		{: >10} ; serial
		{: >10} ; refresh
		{: >10} ; retry
		{: >10} ; expire
		{: >10} ; negative
		)
	", zone.name, zone.ttl, zone.soa.ttl, zone.soa.mname, zone.soa.rname, zone.soa.serial, zone.soa.refresh, zone.soa.retry, zone.soa.expire, zone.soa.minimum};
	for path in &zone.includes_ordered {
		let include = zone.includes.get(path).expect(
			"The includes map should always contain the same keys as in the includes_ordered list",
		);
		let line = match include {
			Include::Readable(_) => format!("$INCLUDE {}", path.display()),
			Include::NotFound => format!(
				"; $INCLUDE {} ; Commented out because the file was not found",
				path.display()
			),
			Include::PermissionDenied => format!(
				"; $INCLUDE {} ; Commented out because we didn't have permission to read the file",
				path.display()
			),
			Include::OtherError => format!(
				"; $INCLUDE {} ; Commented out because we couldn't read the file for some reason. Check the logs of zonewatch to find out more",
				path.display()
			),
		};
		zone_data.push('\n');
		zone_data.push_str(line.as_str());
	}
	zone_data.push('\n');
	zone_data
}

fn write(zone_name: &str, path: &Path, data: &str) -> Result<()> {
	debug!("Saving file {} (zone {zone_name})", path.display());

	// Create parent directories if they don't exist
	let parent = path.parent();
	if let Some(parent) = parent {
		fs::create_dir_all(parent).wrap_err_with(|| {
			format!(
				"Cannot create the parent directory of the zone file {}",
				parent.display()
			)
		})?;
	} else {
		return Err(eyre!(format!(
			"Path `{}` does not have a parent",
			path.display()
		)));
	}

	let mut file = AtomicWriteFile::options()
		.preserve_mode(false)
		.preserve_owner(false)
		.mode(0o444) // Only allow reading, not writing
		.open(path)
		.wrap_err_with(|| {
			format!(
				"Cannot open the new zone file {} using AtomicWriteFile",
				path.display()
			)
		})?;
	file.write_all(data.as_bytes())
		.wrap_err_with(|| format!("Cannot write to new zone file {}", path.display()))?;

	file.commit().wrap_err_with(|| {
		format!(
			"Cannot commit new zone file to the filesystem {}",
			path.display()
		)
	})?;

	Ok(())
}

pub async fn sync_state_to_disc(zone: Zone, tx: &mut Transaction<'_, Sqlite>) -> Result<()> {
	db::write_state(&zone, tx)
		.await
		.wrap_err("Cannot sync state to database")?;

	let zone_file_contents = construct_contents(&zone);
	trace!(
		"Writing contents (zone {})\n{zone_file_contents}",
		zone.name
	);

	let zone_file_name = format!("{}.zone", zone.name);
	let zone_file_path = Path::new(&zone.dir).join(zone_file_name);
	write(&zone.name, &zone_file_path, &zone_file_contents)
		.wrap_err("Cannot write new zone file")?;

	Ok(())
}

#[cfg(test)]
mod test {
	use crate::zone_file::{HashMap, Include, PathBuf};

	#[test]
	fn check_files_from_paths_empty() {
		use std::iter;

		let zone_name = "test";
		let input = iter::empty::<&PathBuf>();
		let expected_output = HashMap::new();
		let actual_output = Include::files_from_paths(zone_name, input);
		assert_eq!(actual_output, expected_output);
	}
}
