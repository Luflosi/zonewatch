// SPDX-FileCopyrightText: 2024 Luflosi <zonewatch@luflosi.de>
// SPDX-License-Identifier: GPL-3.0-only

use crate::db;
use crate::reloader;
use crate::reloader::Reloader;
use blake3::Hash;
use color_eyre::eyre::{Result, WrapErr};
use indoc::formatdoc;
use log::{debug, error, trace, warn};
use sqlx::{Sqlite, Transaction};
use std::collections::HashMap;
use std::path::PathBuf;
use std::{fs, io::Write, path::Path};
use tempfile_fast::Sponge;

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Zone {
	pub name: String,
	pub dir: PathBuf,
	pub ttl: String,
	pub includes: HashMap<PathBuf, Include>,
	pub includes_ordered: Vec<PathBuf>,
	pub soa: Soa,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum Include {
	Readable(Hash),
	// Provide a better user experience by explicitly handling the two probably most common errors
	NotFound,
	PermissionDenied,
	OtherError,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Soa {
	pub ttl: String,
	pub mname: String,
	pub rname: String,
	pub serial: u32,
	pub refresh: String,
	pub retry: String,
	pub expire: String,
	pub minimum: String,
}

impl Include {
	pub fn read_from_fs(file_path: &Path) -> Self {
		trace!("Hashing file {}", file_path.display());
		match fs::read_to_string(file_path) {
			Ok(contents) => {
				let hash = blake3::hash(contents.as_bytes());
				debug!("Hash of included file {}: {}", file_path.display(), hash);
				Self::Readable(hash)
			}
			Err(e) => match e.kind() {
				std::io::ErrorKind::NotFound => {
					warn!("Included file {} is missing", file_path.display());
					Self::NotFound
				}
				std::io::ErrorKind::PermissionDenied => {
					warn!(
						"Permission denied reading included file {}",
						file_path.display()
					);
					Self::PermissionDenied
				}
				_ => {
					error!("Error reading included file {}: {}", file_path.display(), e);
					Self::OtherError
				}
			},
		}
	}

	pub fn files_from_paths<'a>(
		paths: impl Iterator<Item = &'a PathBuf>,
	) -> Result<HashMap<PathBuf, Self>> {
		paths
			.map(|path| Ok((path.clone(), Self::read_from_fs(path))))
			.collect()
	}
}

fn construct_contents(zone: &Zone) -> String {
	let mut zone_data = formatdoc! {"
		; This file was automatically generated by zonewatch.
		; Do not edit or your changes will be overwritten!

		$ORIGIN {}.
		$TTL {}
		@ {} IN SOA {} {} (
		{: >10} ; serial
		{: >10} ; refresh
		{: >10} ; retry
		{: >10} ; expire
		{: >10} ; negative
		)
	", zone.name, zone.ttl, zone.soa.ttl, zone.soa.mname, zone.soa.rname, zone.soa.serial, zone.soa.refresh, zone.soa.retry, zone.soa.expire, zone.soa.minimum};
	for path in &zone.includes_ordered {
		let include = zone.includes.get(path).expect(
			"The includes map should always contain the same keys as in the includes_ordered list",
		);
		let line = match include {
			Include::Readable(_) => format!("$INCLUDE {}", path.display()),
			Include::NotFound => format!("; $INCLUDE {} ; Commented out because the file was not found", path.display()),
			Include::PermissionDenied => format!("; $INCLUDE {} ; Commented out because we didn't have permission to read the file", path.display()),
			Include::OtherError => format!("; $INCLUDE {} ; Commented out because we couldn't read the file for some reason. Check the logs of zonewatch to find out more", path.display()),
		};
		zone_data.push('\n');
		zone_data.push_str(line.as_str());
	}
	zone_data.push('\n');
	zone_data
}

fn write(path: &Path, data: &str, reloader: &Reloader) -> Result<()> {
	debug!("Saving file {}", path.display());
	let mut temp = Sponge::new_for(path).wrap_err_with(|| {
		format!(
			"Cannot create new Sponge for writing to new zone file {}",
			path.display()
		)
	})?;
	temp.write_all(data.as_bytes())
		.wrap_err_with(|| format!("Cannot write to new zone file {}", path.display()))?;

	temp.commit().wrap_err_with(|| {
		format!(
			"Cannot commit new zone file to the filesystem {}",
			path.display()
		)
	})?;

	reloader::execute(reloader)?;

	Ok(())
}

pub async fn sync_state_to_disc(
	zone: Zone,
	reloader: &Reloader,
	tx: &mut Transaction<'_, Sqlite>,
) -> Result<()> {
	db::write_state(&zone, tx)
		.await
		.wrap_err("Cannot sync state to database")?;

	let zone_file_contents = construct_contents(&zone);
	trace!("Writing contents\n{zone_file_contents}");

	let zone_file_name = format!("{}.zone", zone.name);
	let zone_file_path = Path::new(&zone.dir).join(zone_file_name);
	write(&zone_file_path, &zone_file_contents, reloader).wrap_err("Cannot write new zone file")?;

	Ok(())
}

#[cfg(test)]
mod test {
	use crate::zone_file::{HashMap, Include, PathBuf};

	#[test]
	fn check_files_from_paths_empty() {
		use std::iter;

		let input = iter::empty::<&PathBuf>();
		let expected_output = HashMap::new();
		let actual_output =
			Include::files_from_paths(input).expect("This function should not return an error");
		assert_eq!(actual_output, expected_output);
	}
}
