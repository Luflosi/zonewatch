// SPDX-FileCopyrightText: 2024 Luflosi <zonewatch@luflosi.de>
// SPDX-License-Identifier: GPL-3.0-only

use crate::db;
use crate::reloader::Reloader;
use atomic_write_file::{unix::OpenOptionsExt as AtomicOpenOptionsExt, AtomicWriteFile};
use blake3::Hash;
use color_eyre::eyre::{eyre, Result, WrapErr};
use indoc::formatdoc;
use log::{debug, error, trace, warn};
use sqlx::{Sqlite, Transaction};
use std::{
	collections::HashMap,
	fs,
	io::Write,
	os::unix::fs::OpenOptionsExt as UnixOpenOptionsExt,
	path::{Path, PathBuf},
};

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Zone {
	pub name: String,
	pub dir: PathBuf,
	pub ttl: String,
	pub includes: HashMap<PathBuf, Include>,
	pub includes_ordered: Vec<PathBuf>,
	pub soa: Soa,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum Include {
	Readable(Hash),
	// Provide a better user experience by explicitly handling the two probably most common errors
	NotFound,
	PermissionDenied,
	OtherError,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Soa {
	pub ttl: String,
	pub mname: String,
	pub rname: String,
	pub serial: u32,
	pub refresh: String,
	pub retry: String,
	pub expire: String,
	pub minimum: String,
}

impl Include {
	pub fn read_from_fs(file_path: &Path) -> Self {
		trace!("Hashing file {}", file_path.display());
		match fs::read_to_string(file_path) {
			Ok(contents) => {
				let hash = blake3::hash(contents.as_bytes());
				debug!("Hash of included file {}: {}", file_path.display(), hash);
				Self::Readable(hash)
			}
			Err(e) => match e.kind() {
				std::io::ErrorKind::NotFound => {
					warn!("Included file {} is missing", file_path.display());
					Self::NotFound
				}
				std::io::ErrorKind::PermissionDenied => {
					warn!(
						"Permission denied reading included file {}",
						file_path.display()
					);
					Self::PermissionDenied
				}
				_ => {
					error!("Error reading included file {}: {}", file_path.display(), e);
					Self::OtherError
				}
			},
		}
	}

	pub fn files_from_paths<'a>(
		paths: impl Iterator<Item = &'a PathBuf>,
	) -> Result<HashMap<PathBuf, Self>> {
		paths
			.map(|path| Ok((path.clone(), Self::read_from_fs(path))))
			.collect()
	}
}

fn construct_contents(zone: &Zone) -> String {
	let mut zone_data = formatdoc! {"
		; This file was automatically generated by zonewatch.
		; Do not edit or your changes will be overwritten!

		$ORIGIN {}.
		$TTL {}
		@ {} IN SOA {} {} (
		{: >10} ; serial
		{: >10} ; refresh
		{: >10} ; retry
		{: >10} ; expire
		{: >10} ; negative
		)
	", zone.name, zone.ttl, zone.soa.ttl, zone.soa.mname, zone.soa.rname, zone.soa.serial, zone.soa.refresh, zone.soa.retry, zone.soa.expire, zone.soa.minimum};
	for path in &zone.includes_ordered {
		let include = zone.includes.get(path).expect(
			"The includes map should always contain the same keys as in the includes_ordered list",
		);
		let line = match include {
			Include::Readable(_) => format!("$INCLUDE {}", path.display()),
			Include::NotFound => format!("; $INCLUDE {} ; Commented out because the file was not found", path.display()),
			Include::PermissionDenied => format!("; $INCLUDE {} ; Commented out because we didn't have permission to read the file", path.display()),
			Include::OtherError => format!("; $INCLUDE {} ; Commented out because we couldn't read the file for some reason. Check the logs of zonewatch to find out more", path.display()),
		};
		zone_data.push('\n');
		zone_data.push_str(line.as_str());
	}
	zone_data.push('\n');
	zone_data
}

fn write(path: &Path, data: &str, reloader: &Reloader) -> Result<()> {
	debug!("Saving file {}", path.display());

	// Create parent directories if they don't exist
	let parent = path.parent();
	if let Some(parent) = parent {
		fs::create_dir_all(parent).wrap_err_with(|| {
			format!(
				"Cannot create the parent directory of the zone file {}",
				parent.display()
			)
		})?;
	} else {
		return Err(eyre!(format!(
			"Path `{}` does not have a parent",
			path.display()
		)));
	}

	let mut file = AtomicWriteFile::options()
		.preserve_mode(false)
		.preserve_owner(false)
		.mode(0o444) // Only allow reading, not writing
		.open(path)
		.wrap_err_with(|| {
			format!(
				"Cannot open the new zone file {} using AtomicWriteFile",
				path.display()
			)
		})?;
	file.write_all(data.as_bytes())
		.wrap_err_with(|| format!("Cannot write to new zone file {}", path.display()))?;

	file.commit().wrap_err_with(|| {
		format!(
			"Cannot commit new zone file to the filesystem {}",
			path.display()
		)
	})?;

	reloader.execute()?;

	Ok(())
}

pub async fn sync_state_to_disc(
	zone: Zone,
	reloader: &Reloader,
	tx: &mut Transaction<'_, Sqlite>,
) -> Result<()> {
	db::write_state(&zone, tx)
		.await
		.wrap_err("Cannot sync state to database")?;

	let zone_file_contents = construct_contents(&zone);
	trace!("Writing contents\n{zone_file_contents}");

	let zone_file_name = format!("{}.zone", zone.name);
	let zone_file_path = Path::new(&zone.dir).join(zone_file_name);
	write(&zone_file_path, &zone_file_contents, reloader).wrap_err("Cannot write new zone file")?;

	Ok(())
}

#[cfg(test)]
mod test {
	use crate::zone_file::{HashMap, Include, PathBuf};

	#[test]
	fn check_files_from_paths_empty() {
		use std::iter;

		let input = iter::empty::<&PathBuf>();
		let expected_output = HashMap::new();
		let actual_output =
			Include::files_from_paths(input).expect("This function should not return an error");
		assert_eq!(actual_output, expected_output);
	}
}
